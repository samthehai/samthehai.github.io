<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Thuật toán cơ bản: phân tích độ phức tạp giải thuật | Hai Sam's Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau."><meta name=generator content="Hugo 0.79.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css><meta property="og:title" content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật"><meta property="og:description" content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau."><meta property="og:type" content="article"><meta property="og:url" content="https://samthehai.github.io/posts/basic_algorithm/"><meta property="article:published_time" content="2020-10-24T00:00:00+00:00"><meta property="article:modified_time" content="2020-10-24T00:00:00+00:00"><meta itemprop=name content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật"><meta itemprop=description content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau."><meta itemprop=datePublished content="2020-10-24T00:00:00+00:00"><meta itemprop=dateModified content="2020-10-24T00:00:00+00:00"><meta itemprop=wordCount content="1490"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật"><meta name=twitter:description content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Hai Sam's Blog</a><div class="flex-l items-center"></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://samthehai.github.io/posts/basic_algorithm/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://samthehai.github.io/posts/basic_algorithm/&text=Thu%e1%ba%adt%20to%c3%a1n%20c%c6%a1%20b%e1%ba%a3n:%20ph%c3%a2n%20t%c3%adch%20%c4%91%e1%bb%99%20ph%e1%bb%a9c%20t%e1%ba%a1p%20gi%e1%ba%a3i%20thu%e1%ba%adt" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://samthehai.github.io/posts/basic_algorithm/&title=Thu%e1%ba%adt%20to%c3%a1n%20c%c6%a1%20b%e1%ba%a3n:%20ph%c3%a2n%20t%c3%adch%20%c4%91%e1%bb%99%20ph%e1%bb%a9c%20t%e1%ba%a1p%20gi%e1%ba%a3i%20thu%e1%ba%adt" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30C64 50.568 50.568 64 34 64zM26.354 48.137V27.71h-6.789v20.427H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">Thuật toán cơ bản: phân tích độ phức tạp giải thuật</h1><time class="f6 mv4 dib tracked" datetime=2020-10-24T00:00:00Z>October 24, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=1-giới-thiệu>1. Giới thiệu</h1><p>Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.</p><p>Vậy thì thuật toán là gi?</p><p>Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.</p><p>Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau.</p><p>Ví dụ:</p><p>Vấn đề sắp xếp:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>- Input: Nhận vào một chuỗi các khoá x1, x2, x3, ...
- Output: Sắp xếp lại thứ tự của chuỗi đầu vào sao cho theo thứ tự x1&#39; &lt;= x2&#39; &lt;= x3&#39; ...
</code></pre></div><p>Để giải quyết vấn đề sắp xếp ta có các thuật toán sắp xếp: merge sort, quick sort, insertion sort, selection sort, &mldr;</p><h1 id=2-phân-tích-thuật-toán>2. Phân tích thuật toán</h1><p>Có nhiều thuật toán để giải quyết một vấn đề.</p><p>Vì vậy sẽ nảy sinh vấn đề làm sao để lựa chọn thuật toán nào cho vấn đề nào.</p><p>Để giải quyết vấn đề đó chúng ta sẽ phải phân tích thuật toán.</p><p>Có hai công cụ quan trọng để đánh giá thuật toán: mô hình RAM, Big-O</p><h2 id=21-mô-hình-ram>2.1. Mô hình RAM</h2><ol><li><p>Mỗi thao tác đơn giản (+, -, *, /, if, call) tốn đúng một bước</p></li><li><p>Vòng lặp và hàm thì không phải là thao tác đơn giản và sẽ tốn nhiều hơn 1 bước để thực hiện</p></li><li><p>Mỗi thao tác truy xuất bộ nhớ sẽ tốn đúng một bước</p></li></ol><p>Hiển nhiên chúng ta có thể thấy các điều kiện ở trên chỉ có tính tương đối và không đúng với thực tiễn.</p><p>Nhưng khi áp dụng mô hình RAM nó lại khiến cho việc phân tích thuật toán trở nên đơn giản và hiệu quả.</p><h3 id=211-độ-phức-tạp-theo-thời-gian>2.1.1 Độ phức tạp theo thời gian</h3><p>Khi áp dụng mô hình trên người ta thường sẽ để ý đến các trường hợp:</p><ol><li><p>Trường hợp tốt nhất (best-case) là số lượng bước ít nhất cần để thực hiện thuật toán</p></li><li><p>Trường hợp tệ nhất (worst-case) là số lượng bước nhiều nhất cần để thực hiện thuật toán</p></li><li><p>Trường hợp trung bình (average-case) là số lượng bước trung bình để thực hiện thuật toán</p></li></ol><p>Trường hợp tệ nhất đóng vai trò quan trọng trong thực tiễn và thường ta chỉ quan tâm đến nó mà bỏ qua hai trường hợp còn lại.</p><h3 id=212-cách-xác-định-độ-phức-tạp-theo-thời-gian>2.1.2 Cách xác định độ phức tạp theo thời gian</h3><p>Độ phức tạp theo thời gian dùng để ước lượng thời gian cần thiết để thực thi giải thuật và được tính toán dựa vào số bước thực hiện các thao tác cơ bản.</p><p>Ví dụ: Hãy xác định thời gian thiện hiện thuật toán dưới đây</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#75715e>// Tính toán tìm phần tử lớn nhất trong mảng
</span><span style=color:#75715e></span><span style=color:#a6e22e>Algorithm</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>a</span>):
    <span style=color:#a6e22e>max</span> <span style=color:#960050;background-color:#1e0010>←</span> <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>0</span>]
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>1</span> <span style=color:#a6e22e>to</span> len(<span style=color:#a6e22e>a</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>] &gt; <span style=color:#a6e22e>max</span>
            <span style=color:#a6e22e>max</span> <span style=color:#960050;background-color:#1e0010>←</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>]
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>max</span>
</code></pre></div><p>Câu trả lời chính xác tuỳ thuộc vào nhiều yếu tố như là giá trị đầu vào, ngôn ngữ lập trình và môi trường thực thi, trình biên dịch, hệ điều hành và phần cứng, &mldr;</p><p>Vì vậy chúng ta thường chỉ muốn ước lượng thời gian thực thi thuật toán tương đối chỉ dựa vào thuật toán và giá trị đầu vào.
Điều này có thể được thực hiện bằng cách chọn một thao tác cơ bản mà thuật toán lặp lại nhiều lần và tính toán độ phức tạp thời gian như là số thao tác cơ bản cần để thực hiện thuật toán với input array có độ dài n</p><p>Đối với thuật toán ở trên ta có thể chọn thao tác so sánh a[i] > max làm thao tác cơ bản.</p><ol><li><p>Bởi vì phép toán so sánh được sử dụng xuyên suốt thuật toán nên là điều này sẽ cho phép phản ánh đúng đắn thời gian chạy của thuật toán</p></li><li><p>Hơn nữa thời gian thực hiện của phép so sánh là hằng số và không phụ thuộc vào kích thước của array.</p></li></ol><h4 id=2121-độ-phức-tạp-thời-gian-tệ-nhất-worst-case>2.1.2.1. Độ phức tạp thời gian tệ nhất (worst-case)</h4><p>Xem xét thuật toán dưới này:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#75715e>// Kiểm tra xem array a có chứa x.
</span><span style=color:#75715e></span><span style=color:#a6e22e>Algorithm</span> <span style=color:#a6e22e>contains</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>x</span>):
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span> <span style=color:#a6e22e>to</span> len(<span style=color:#a6e22e>a</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>]
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</code></pre></div><p>Phép toán so sánh x == a[i] có thể được dùng làm phép toán cơ bản trong trường hợp này.
Tuy nhiên như chúng ta thấy trong trường hợp này số lượng phép toán so sánh được thực hiện không chỉ phụ thuộc vào số lượng phần tử array n mà còn phụ thộc vào giá trị của x và giá trị của các phần tử trong a.</p><ol><li><p>Nếu không tìm thấy x thì số phép toán so sánh là n</p></li><li><p>Nếu x == a[0] thì chỉ cần một phép so sánh .</p></li></ol><p>Vì lý do này mà thông thường ta sẽ chọn xác định trường hợp thời gian tệ nhất của thuật toán:</p><ol><li><p>Cho T1(n), T2(n), &mldr; là thời gian thực thi của tất cả các giá trị có thể có của input kích thước n</p></li><li><p>Độ phức tạp thời gian trong trường hợp tệ nhất sẽ là W(n) = max(T1(n), T2(n), &mldr;)</p></li></ol><p>Vì vậy độ phức thời gian trong trường hợp tệ nhất sẽ là n</p><h4 id=2122-độ-phức-tạp-thời-gian-trung-bình-average-case>2.1.2.2 Độ phức tạp thời gian trung bình (average-case)</h4><p>Độ phức tạp thời gian trung bình thì ít phổ biến hơn, có thể được định nghĩa là số bước trung bình cần thiết để thực hiện thuật toán.</p><ol><li><p>Cho T1(n), T2(n), &mldr; là thời gian thực thi của tất cả các giá tri có thể có của input kích thước n, và P1(n), P2(n), &mldr;là xác xuất của những input này.</p></li><li><p>Độ phức tạp thời gian trung bình (average-case) được định nghĩa là P1(n)T1(n) + P2(n)T2(n) + &mldr;</p></li></ol><p>Độ phức tạp thời gian trung bình khó để tính toán và ý nghĩa của nó là chủ đề gây tranh cãi.</p><h2 id=22-big-o>2.2. Big-O</h2><p>Như ở trên ta có nói thời gian thực thi của một thuật toán phụ thuộc vào nhiều yếu tố và khó để xác định chính xác nó.
Vì vậy khi nói đến việc tính toán thời gian thực thi của thuật toán đó chính là thời gian ước lượng, việc này thì thực ra không gây ra vấn đề gì. Bởi vì trong khoa học máy tính thứ được quan tâm nhiều hơn đối với một thuật toán là thời gian thực thi của nó sẽ tăng nhanh như thế nào khi số lượng phần tử đầu vào thay đổi.</p><p>Từ đó khái niệm Big-O được ra đời.</p><p>Và sau đây là một định nghĩa toán học của Big-O</p><blockquote><p>Cho T(n) và f(n) là hai hàm số dương. Ta viết T(n) = O(f(n)) có nghĩa rằng c . f(n) là cận trên của T(n). Vì vậy tồn tại một hằng số c sao cho T(n) luôn luôn &lt;= c . f(n) với một số n đủ lớn (n >= n0)</p></blockquote><p>Hay nói một cách dễ hiểu hơn:</p><blockquote><p>T(n) = O(f(n)) có nghĩa là T(n) không tăng nhanh hơn f(n).</p></blockquote><p>Lưu ý: Ngoài Big-O, còn có hai khái niệm khác Big Omega(Ω) và Big Thelta(Θ):</p><ol><li><p>Big Omega f(n) = Ω(g(n)) có nghĩa là c . g(n) là cận dưới của f(n), có tồn tại một số n >= n0 sao cho f(n) luôn nhỏ hơn c . g(n)</p></li><li><p>Big Thelta f(n) = Θ(g(n)) có nghĩa là c1 . g(n) là cận dưới và c2 . g(n) là cận trên của f(n), có tồn tại một số n >= n0 sao cho c1.g(n) &lt;= f(n) &lt;= c2.g(n)</p></li></ol><h3 id=221-giới-thiệu-về-một-số-hàm-số-tăng-cơ-bản>2.2.1. Giới thiệu về một số hàm số tăng cơ bản</h3><h4 id=2211-hàm-số-hằng>2.2.1.1 Hàm số hằng</h4><p>Đây là trường hợp đơn giản và lý tưởng nhất cho mọi thuật toán T(n) = O(1).</p><p>Theo như định nghĩa có nghĩa là sẽ tồn tại một giá trị n đủ lớn n >= n0 sao cho T(n) luôn luôn nhỏ hơn một giá trị cố định không phụ thuộc vào n.</p><h3 id=2212-hàm-số-tuyến-tính>2.2.1.2. Hàm số tuyến tính</h3><p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n).</p><p>Áp dụng định nghĩa của Big-O, điều này có nghĩa là tồn tại một số n đủ lớn n0 sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n</p><h3 id=2213-hàm-số-mũ>2.2.1.3 Hàm số mũ</h3><p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n2).</p><p>Một lần nữa áp dụng định nghĩa, điều này có nghĩa là tồn tại một số n đủ lớn sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n2.</p><h3 id=2214-ví-dụ-về-thay-đổi-thời-gian-thực-thi-theo-đầu-vào>2.2.1.4 Ví dụ về thay đổi thời gian thực thi theo đầu vào</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQ6MsN%2FbtqubeWgXC4%2FXqPDbr2YJLA03Gx5g9VIJk%2Fimg.jpg" alt=chart></p><h1 id=nguồn-tham-khảo>Nguồn tham khảo</h1><ol><li><p><a href=https://yourbasic.org/>https://yourbasic.org/</a></p></li><li><p>The Algorithm Design Manual – Skiena, Steven S.</p></li></ol><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://samthehai.github.io>&copy; Hai Sam's Blog 2021</a><div></div></div></footer></body></html>