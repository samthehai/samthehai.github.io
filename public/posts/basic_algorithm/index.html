<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Thuật toán cơ bản: phân tích độ phức tạp giải thuật - Hai Sam&#39;s Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật">
<meta itemprop="description" content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau.">
<meta itemprop="datePublished" content="2020-10-24T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-10-24T00:00:00+00:00" />
<meta itemprop="wordCount" content="1490">



<meta itemprop="keywords" content="Programming,Algorithm," />
<meta property="og:title" content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật" />
<meta property="og:description" content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://samthehai.github.io/posts/basic_algorithm/" />
<meta property="article:published_time" content="2020-10-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-10-24T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Thuật toán cơ bản: phân tích độ phức tạp giải thuật"/>
<meta name="twitter:description" content="1. Giới thiệu Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.
Vậy thì thuật toán là gi?
Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.
Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://samthehai.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://samthehai.github.io/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://samthehai.github.io/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://samthehai.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://samthehai.github.io/">
				<img src="https://avatars.githubusercontent.com/u/28634475?s=460&amp;u=f4564e31e24dbd90802eaf4a18d2d9e578c77108&amp;v=4" alt="Hai Sam&#39;s Blog" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://samthehai.github.io/">Hai Sam&#39;s Blog</a></h1>
	<div class="site-description"><p>Hai Sam, a programming enthusiasm father</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/samthehai" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li><li><a href="#" class="scheme-toggle" id="scheme-toggle"></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">24</span>
							<span class="rest">Oct 2020</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Thuật toán cơ bản: phân tích độ phức tạp giải thuật</h1>
				</div>
			</div>
					
			<div class="markdown">
				<h1 id="1-giới-thiệu">1. Giới thiệu</h1>
<p>Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.</p>
<p>Vậy thì thuật toán là gi?</p>
<p>Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.</p>
<p>Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau.</p>
<p>Ví dụ:</p>
<p>Vấn đề sắp xếp:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">- Input: Nhận vào một chuỗi các khoá x1, x2, x3, ...
- Output: Sắp xếp lại thứ tự của chuỗi đầu vào sao cho theo thứ tự x1&#39; &lt;= x2&#39; &lt;= x3&#39; ...
</code></pre></div><p>Để giải quyết vấn đề sắp xếp ta có các thuật toán sắp xếp: merge sort, quick sort, insertion sort, selection sort, &hellip;</p>
<h1 id="2-phân-tích-thuật-toán">2. Phân tích thuật toán</h1>
<p>Có nhiều thuật toán để giải quyết một vấn đề.</p>
<p>Vì vậy sẽ nảy sinh vấn đề làm sao để lựa chọn thuật toán nào cho vấn đề nào.</p>
<p>Để giải quyết vấn đề đó chúng ta sẽ phải phân tích thuật toán.</p>
<p>Có hai công cụ quan trọng để đánh giá thuật toán: mô hình RAM, Big-O</p>
<h2 id="21-mô-hình-ram">2.1. Mô hình RAM</h2>
<ol>
<li>
<p>Mỗi thao tác đơn giản (+, -, *, /, if, call) tốn đúng một bước</p>
</li>
<li>
<p>Vòng lặp và hàm thì không phải là thao tác đơn giản và sẽ tốn nhiều hơn 1 bước để thực hiện</p>
</li>
<li>
<p>Mỗi thao tác truy xuất bộ nhớ sẽ tốn đúng một bước</p>
</li>
</ol>
<p>Hiển nhiên chúng ta có thể thấy các điều kiện ở trên chỉ có tính tương đối và không đúng với thực tiễn.</p>
<p>Nhưng khi áp dụng mô hình RAM nó lại khiến cho việc phân tích thuật toán trở nên đơn giản và hiệu quả.</p>
<h3 id="211-độ-phức-tạp-theo-thời-gian">2.1.1 Độ phức tạp theo thời gian</h3>
<p>Khi áp dụng mô hình trên người ta thường sẽ để ý đến các trường hợp:</p>
<ol>
<li>
<p>Trường hợp tốt nhất (best-case) là số lượng bước ít nhất cần để thực hiện thuật toán</p>
</li>
<li>
<p>Trường hợp tệ nhất (worst-case) là số lượng bước nhiều nhất cần để thực hiện thuật toán</p>
</li>
<li>
<p>Trường hợp trung bình (average-case) là số lượng bước trung bình để thực hiện thuật toán</p>
</li>
</ol>
<p>Trường hợp tệ nhất đóng vai trò quan trọng trong thực tiễn và thường ta chỉ quan tâm đến nó mà bỏ qua hai trường hợp còn lại.</p>
<h3 id="212-cách-xác-định-độ-phức-tạp-theo-thời-gian">2.1.2 Cách xác định độ phức tạp theo thời gian</h3>
<p>Độ phức tạp theo thời gian dùng để ước lượng thời gian cần thiết để thực thi giải thuật và được tính toán dựa vào số bước thực hiện các thao tác cơ bản.</p>
<p>Ví dụ: Hãy xác định thời gian thiện hiện thuật toán dưới đây</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#008000">// Tính toán tìm phần tử lớn nhất trong mảng
</span><span style="color:#008000"></span>Algorithm max(a):
    max <span style="">←</span> a[0]
    <span style="color:#00f">for</span> i = 1 to len(a)-1
        <span style="color:#00f">if</span> a[i] &gt; max
            max <span style="">←</span> a[i]
    <span style="color:#00f">return</span> max
</code></pre></div><p>Câu trả lời chính xác tuỳ thuộc vào nhiều yếu tố như là giá trị đầu vào, ngôn ngữ lập trình và môi trường thực thi, trình biên dịch, hệ điều hành và phần cứng, &hellip;</p>
<p>Vì vậy chúng ta thường chỉ muốn ước lượng thời gian thực thi thuật toán tương đối chỉ dựa vào thuật toán và giá trị đầu vào.
Điều này có thể được thực hiện bằng cách chọn một thao tác cơ bản mà thuật toán lặp lại nhiều lần và tính toán độ phức tạp thời gian như là số thao tác cơ bản cần để thực hiện thuật toán với input array có độ dài n</p>
<p>Đối với thuật toán ở trên ta có thể chọn thao tác so sánh a[i] &gt; max làm thao tác cơ bản.</p>
<ol>
<li>
<p>Bởi vì phép toán so sánh được sử dụng xuyên suốt thuật toán nên là điều này sẽ cho phép phản ánh đúng đắn thời gian chạy của thuật toán</p>
</li>
<li>
<p>Hơn nữa thời gian thực hiện của phép so sánh là hằng số và không phụ thuộc vào kích thước của array.</p>
</li>
</ol>
<h4 id="2121-độ-phức-tạp-thời-gian-tệ-nhất-worst-case">2.1.2.1. Độ phức tạp thời gian tệ nhất (worst-case)</h4>
<p>Xem xét thuật toán dưới này:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#008000">// Kiểm tra xem array a có chứa x.
</span><span style="color:#008000"></span>Algorithm contains(a, x):
    <span style="color:#00f">for</span> i = 0 to len(a)-1
        <span style="color:#00f">if</span> x == a[i]
            <span style="color:#00f">return</span> <span style="color:#00f">true</span>
    <span style="color:#00f">return</span> <span style="color:#00f">false</span>
</code></pre></div><p>Phép toán so sánh x == a[i] có thể được dùng làm phép toán cơ bản trong trường hợp này.
Tuy nhiên như chúng ta thấy trong trường hợp này số lượng phép toán so sánh được thực hiện không chỉ phụ thuộc vào số lượng phần tử array n mà còn phụ thộc vào giá trị của x và giá trị của các phần tử trong a.</p>
<ol>
<li>
<p>Nếu không tìm thấy x thì số phép toán so sánh là n</p>
</li>
<li>
<p>Nếu x == a[0] thì chỉ cần một phép so sánh .</p>
</li>
</ol>
<p>Vì lý do này mà thông thường ta sẽ chọn xác định trường hợp thời gian tệ nhất của thuật toán:</p>
<ol>
<li>
<p>Cho T1(n), T2(n), &hellip; là thời gian thực thi của tất cả các giá trị có thể có của input kích thước n</p>
</li>
<li>
<p>Độ phức tạp thời gian trong trường hợp tệ nhất sẽ là W(n) = max(T1(n), T2(n), &hellip;)</p>
</li>
</ol>
<p>Vì vậy độ phức thời gian trong trường hợp tệ nhất sẽ là n</p>
<h4 id="2122-độ-phức-tạp-thời-gian-trung-bình-average-case">2.1.2.2 Độ phức tạp thời gian trung bình (average-case)</h4>
<p>Độ phức tạp thời gian trung bình thì ít phổ biến hơn, có thể được định nghĩa là số bước trung bình cần thiết để thực hiện thuật toán.</p>
<ol>
<li>
<p>Cho T1(n), T2(n), &hellip; là thời gian thực thi của tất cả các giá tri có thể có của input kích thước n, và P1(n), P2(n), &hellip;là xác xuất của những input này.</p>
</li>
<li>
<p>Độ phức tạp thời gian trung bình (average-case) được định nghĩa là P1(n)T1(n) + P2(n)T2(n) + &hellip;</p>
</li>
</ol>
<p>Độ phức tạp thời gian trung bình khó để tính toán và ý nghĩa của nó là chủ đề gây tranh cãi.</p>
<h2 id="22-big-o">2.2. Big-O</h2>
<p>Như ở trên ta có nói thời gian thực thi của một thuật toán phụ thuộc vào nhiều yếu tố và khó để xác định chính xác nó.
Vì vậy khi nói đến việc tính toán thời gian thực thi của thuật toán đó chính là thời gian ước lượng, việc này thì thực ra không gây ra vấn đề gì. Bởi vì trong khoa học máy tính thứ được quan tâm nhiều hơn đối với một thuật toán là thời gian thực thi của nó sẽ tăng nhanh như thế nào khi số lượng phần tử đầu vào thay đổi.</p>
<p>Từ đó khái niệm Big-O được ra đời.</p>
<p>Và sau đây là một định nghĩa toán học của Big-O</p>
<blockquote>
<p>Cho T(n) và f(n) là hai hàm số dương. Ta viết T(n) = O(f(n)) có nghĩa rằng c . f(n) là cận trên của T(n). Vì vậy tồn tại một hằng số c sao cho T(n) luôn luôn &lt;= c . f(n) với một số n đủ lớn (n &gt;= n0)</p>
</blockquote>
<p>Hay nói một cách dễ hiểu hơn:</p>
<blockquote>
<p>T(n) = O(f(n)) có nghĩa là T(n) không tăng nhanh hơn f(n).</p>
</blockquote>
<p>Lưu ý: Ngoài Big-O, còn có hai khái niệm khác Big Omega(Ω) và Big Thelta(Θ):</p>
<ol>
<li>
<p>Big Omega f(n) = Ω(g(n)) có nghĩa là c . g(n) là cận dưới của f(n), có tồn tại một số n &gt;= n0 sao cho f(n) luôn nhỏ hơn c . g(n)</p>
</li>
<li>
<p>Big Thelta f(n) = Θ(g(n)) có nghĩa là c1 . g(n) là cận dưới và c2 . g(n) là cận trên của f(n), có tồn tại một số n &gt;= n0 sao cho c1.g(n) &lt;= f(n) &lt;= c2.g(n)</p>
</li>
</ol>
<h3 id="221-giới-thiệu-về-một-số-hàm-số-tăng-cơ-bản">2.2.1. Giới thiệu về một số hàm số tăng cơ bản</h3>
<h4 id="2211-hàm-số-hằng">2.2.1.1 Hàm số hằng</h4>
<p>Đây là trường hợp đơn giản và lý tưởng nhất cho mọi thuật toán T(n) = O(1).</p>
<p>Theo như định nghĩa có nghĩa là sẽ tồn tại một giá trị n đủ lớn n &gt;= n0 sao cho T(n) luôn luôn nhỏ hơn một giá trị cố định không phụ thuộc vào n.</p>
<h3 id="2212-hàm-số-tuyến-tính">2.2.1.2. Hàm số tuyến tính</h3>
<p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n).</p>
<p>Áp dụng định nghĩa của Big-O, điều này có nghĩa là tồn tại một số n đủ lớn n0 sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n</p>
<h3 id="2213-hàm-số-mũ">2.2.1.3 Hàm số mũ</h3>
<p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n2).</p>
<p>Một lần nữa áp dụng định nghĩa, điều này có nghĩa là tồn tại một số n đủ lớn sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n2.</p>
<h3 id="2214-ví-dụ-về-thay-đổi-thời-gian-thực-thi-theo-đầu-vào">2.2.1.4 Ví dụ về thay đổi thời gian thực thi theo đầu vào</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQ6MsN%2FbtqubeWgXC4%2FXqPDbr2YJLA03Gx5g9VIJk%2Fimg.jpg" alt="chart"></p>
<h1 id="nguồn-tham-khảo">Nguồn tham khảo</h1>
<ol>
<li>
<p><a href="https://yourbasic.org/">https://yourbasic.org/</a></p>
</li>
<li>
<p>The Algorithm Design Manual – Skiena, Steven S.</p>
</li>
</ol>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/programming">Programming</a></li>
							
							<li><a href="/tags/algorithm">Algorithm</a></li>
							
						</ul>
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'Hai Sam\u0027s Blog';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the </a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2021  © Copyright notice |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
